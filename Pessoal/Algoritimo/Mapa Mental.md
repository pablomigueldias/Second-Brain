| **Nível 1**                 | **Nível 2: Área Principal**           | **Nível 3: Estrutura/Conceito**   | **Nível 4: Tópicos de Estudo (Implementação)**                                                                   | **Nível 5: Análise e Aprofundamento**                                                             |
| --------------------------- | ------------------------------------- | --------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| **1. FUNDAMENTOS**          | **1.1. Base de Programação (Python)** | **Lógica e Sintaxe**              | Variáveis, Tipos de Dados, Operadores, I/O.                                                                      | Uso de Ambientes de Desenvolvimento (IDE/Jupyter).                                                |
|                             |                                       | **Estruturas de Controle**        | Condicionais (`if`, `elif`, `else`), Laços (`for`, `while`).                                                     | Escopo de Variáveis (Global vs. Local).                                                           |
|                             |                                       | **Modularização**                 | Funções, Passagem de Parâmetros (por valor/referência), Funções aninhadas.                                       | **Recursão:** Entendimento de Pilha de Chamadas (Call Stack) e Caso Base.                         |
|                             | **1.2. Análise de Complexidade**      | **Notação Assintótica**           | **Big O** ($O$), **Big Omega** ($\Omega$), **Big Theta** ($\Theta$).                                             | – Comparação visual das curvas de crescimento (ex: $O(n \log n)$ vs $O(n^2)$).                    |
|                             |                                       | **Cálculo da Complexidade**       | Regras para Loops Aninhados, Condicionais e Chamadas de Função.                                                  | Análise de Complexidade de Espaço (Memória).                                                      |
|                             |                                       | **Classes de Complexidade**       | $O(1)$ (Constante), $O(\log n)$ (Logarítmica), $O(n)$ (Linear), $O(n \log n)$, $O(n^2)$, $O(2^n)$ (Exponencial). | Domínio do Teorema Mestre (Master Theorem) para Recorrências.                                     |
| **2. ESTRUTURAS DE DADOS**  | **2.1. Estruturas Nativas (Python)**  | **Listas (Arrays Dinâmicos)**     | Métodos de lista, _List Comprehensions_, custo de inserção no final vs. no meio.                                 | **Array vs. Lista Ligada** – Comparação de acesso e modificação.                                  |
|                             |                                       | **Tabelas Hash (Dicionários)**    | Função Hash, Fator de Carga, Como Python implementa `dict`.                                                      | **Tratamento de Colisões** (Encadeamento e Sondagem).                                             |
|                             | **2.2. Estruturas Lineares**          | **Listas Encadeadas**             | **Nó (Node)**: Criação de classe, Ponteiros.                                                                     | Implementação Duplamente Encadeada (Vantagens e Desvantagens).                                    |
|                             |                                       | **Pilhas (Stack)**                | LIFO, Operações `Push`, `Pop`, `Peek`.                                                                           | Aplicações: Avaliação de Expressões (Notação Polonesa) e Backtracking.                            |
|                             |                                       | **Filas (Queue)**                 | FIFO, Operações `Enqueue`, `Dequeue`.                                                                            | Tipos: Fila Circular, Fila de Prioridade (usando Heap).                                           |
| **3. ALGORITMOS BÁSICOS**   | **3.1. Busca**                        | **Busca Linear**                  | Implementação e análise do Pior Caso ($O(n)$).                                                                   | Busca com Sentinela (Otimização).                                                                 |
|                             |                                       | **Busca Binária**                 | Requisito: Vetor Ordenado. Implementação Iterativa vs. Recursiva.                                                | Análise de $O(\log n)$ e aplicações em grandes bases de dados.                                    |
|                             | **3.2. Ordenação (Sort)**             | **$O(n^2)$ (Quadráticos)**        | Bubble Sort, Insertion Sort, Selection Sort.                                                                     | Entender por que são úrightarrows (Úteis apenas para $n$ muito pequeno ou parcialmente ordenado). |
|                             |                                       | **$O(n \log n)$ (Eficientes)**    | **Merge Sort:** Divisão e Conquista, Fusão (Merge) de listas.                                                    | **Quick Sort:** Escolha de Pivô (Mediana de 3), Particionamento. Análise do Pior Caso.            |
|                             |                                       | **Não-Comparativos**              | Counting Sort, Radix Sort.                                                                                       | Análise de $O(n+k)$ – Quando são mais rápidos que $O(n \log n)$.                                  |
| **4. ESTRUTURAS AVANÇADAS** | **4.1. Árvores**                      | **Árvore Binária de Busca (BST)** | Propriedades, Inserção, Remoção. Percurso (In-order, Pre-order, Post-order).                                     | Análise: $O(\log n)$ no Caso Médio, $O(n)$ no Pior Caso (Desbalanceamento).                       |
|                             |                                       | **Árvores de Balanceamento**      | **AVL Trees** e **Red-Black Trees** (RB).                                                                        | Conceito de Rotações (Simples, Dupla) e como mantêm a complexidade $O(\log n)$.                   |
|                             |                                       | **Heaps**                         | Min-Heap e Max-Heap. Operações `Heapify`, `Insert`, `Extract-Min/Max`.                                           | Aplicação: **Filas de Prioridade**.                                                               |
|                             | **4.2. Grafos**                       | **Conceitos e Representação**     | Vértices, Arestas (Ponderadas/Não Ponderadas). Tipos (DAG, Completo, Bipartido).                                 | **Lista de Adjacência** vs. **Matriz de Adjacência** (Qual usar e por quê).                       |
|                             |                                       | **Algoritmos de Busca**           | **Busca em Largura (BFS)**, **Busca em Profundidade (DFS)**.                                                     | Aplicações: Encontrar Componentes Conexos, Ordenação Topológica.                                  |
|                             |                                       | **Caminho Mínimo**                | **Algoritmo de Dijkstra** (Pesos Não-Negativos).                                                                 | **Algoritmo de Bellman-Ford** (Pesos Negativos, Detecção de Ciclos Negativos).                    |
|                             |                                       | **Árvore Geradora Mínima (MST)**  | Algoritmos de **Prim** e **Kruskal** (e suas implementações Gulosas).                                            | Aplicações em redes e custo mínimo de conexões.                                                   |
| **5. TÉCNICAS AVANÇADAS**   | **5.1. Programação Dinâmica (DP)**    | **Conceitos e Estratégias**       | **Memorização** (Top-Down), **Tabulação** (Bottom-Up). Princípio da Subestrutura Ótima.                          | Implementação: Problema da Mochila (Knapsack 0/1), Sequência Comum Mais Longa (LCS).              |
|                             | **5.2. Algoritmos Gulosos (Greedy)**  | **Propriedades**                  | Subestrutura Ótima e Propriedade Gulosa da Escolha.                                                              | Exemplos: Problema do Troco, Algoritmo de Huffman.                                                |
|                             | **5.3. Outras Técnicas**              | **Backtracking**                  | Busca exaustiva de soluções com poda de ramo (Branch and Bound).                                                 | Aplicações: Problema das N-Rainhas, Solucionador de Sudoku.                                       |