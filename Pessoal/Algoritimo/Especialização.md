
Algoritmos Probabilísticos e de Otimização

| **Área**                 | **Tópicos de Estudo**                                                                                                                  | **Por que estudar?**                                                                          |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **1.1. Otimização**      | **Algoritmos Genéticos:** Inspiração biológica para encontrar soluções aproximadas.                                                    | Usado em problemas complexos onde a busca exaustiva é inviável (otimização de rotas, design). |
|                          | **Simulated Annealing (Recozimento Simulado):** Outra técnica meta-heurística para otimização global.                                  | Ótimo para escapar de mínimos locais em paisagens de otimização.                              |
| **1.2. Probabilísticos** | **Algoritmos de Las Vegas:** Sempre produzem o resultado correto, mas o tempo de execução é aleatório.                                 | Ex: Quicksort randomizado.                                                                    |
|                          | **Algoritmos de Monte Carlo:** O tempo de execução é fixo, mas a resposta pode ser incorreta com uma pequena probabilidade controlada. | Ex: Testes de primalidade (como o de Miller-Rabin).                                           |
Algoritmos Específicos e Teóricos

| **Área**                               | **Tópicos de Estudo**                                                                                     | **Por que estudar?**                                                                                                           |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **2.1. Teoria da Computação**          | **Classes de Complexidade:** Aprofundamento em P, NP, NP-Completo, e NP-Difícil.                          | Entender os limites da computação e por que alguns problemas são intrinsecamente difíceis (ex: Problema do Caixeiro Viajante). |
|                                        | **Redução de Problemas:** Transformar um problema em outro para provar sua complexidade.                  | Fundamental para a teoria e pesquisa.                                                                                          |
| **2.2. Estruturas de Dados Avançadas** | **Árvores B e B+ Tree:** Estruturas otimizadas para sistemas de armazenamento em disco (Bancos de Dados). | Crucial para entender a arquitetura interna de Bancos de Dados e Sistemas de Arquivos.                                         |
|                                        | **Skip Lists:** Alternativa probabilística a árvores balanceadas.                                         | Útil em concorrência, pois é mais fácil de manter em ambientes paralelos.                                                      |
| **2.3. String Matching**               | **Algoritmos KMP (Knuth-Morris-Pratt)** e **Rabin-Karp**.                                                 | Usados em busca de texto eficiente, como em editores de código e sistemas de busca.                                            |
Computação Paralela e Distribuída

| **Área**                    | **Tópicos de Estudo**                                                                      | **Por que estudar?**                                                                            |
| --------------------------- | ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
| **Paralelismo**             | Algoritmos de ordenação e multiplicação de matrizes adaptados para múltiplas CPUs ou GPUs. | Essencial em Big Data, Machine Learning e Computação de Alto Desempenho.                        |
| **Algoritmos Distribuídos** | Algoritmos de Consenso (Paxos, Raft).                                                      | Base para sistemas distribuídos e Blockchain, garantindo que múltiplos nós cheguem a um acordo. |
